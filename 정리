프로그램명
jdk-8u171-windows-x64
mariadb-10.2.16-winx64
spring-tool-suite-3.9.5.RELEASE-e4.8.0-win32-x86_64

-- 18.07.08
1. 프로그램 설치 및 git hub 연동
2. sts 에 gradle 플러그인 설치
3. mariadb 설치 (설치시 utf-8옵션으로 설치)

-- 18.07.09
1. gradle 플러그인 설치
 - buildship gradle integration -> x 안됨.
 - sts 에선 dashboard에서 플러그인으로 설치해야함. (extension -> gradle support)

* sts에서 github 접속안되는 원인 (1.7에선 안됨, 1.8에선 됨)
 - 이클립스와 다른거 같음.

2. 샘플 프로젝트 생성
 - springboottest (프로젝트이름에 _가 들어가면 생성안됨)

3. 샘플 코드 테스트
 - helloworld출력 (gradle에 기본 dependency만 남겨두고 실행)
 - run as -> spring app -> http://localhost:8080
 - com.handashi.HelloRestController.java

-- 18.07.11
1. spring project로 생성한 프로젝트 샘플을 developPoject 로 이동
 - developPoject Project facets -> web 프로젝트 설정
 - developProject spring tools -> spring Nature 로 변경 
 - configure -> gradle project로 변경
 - gradle 관련 폴더및 파일, src 폴더 복사
 - spring boot app 기동 시켜 샘플 페이지 테스트

-- 18.07.13
1. sts 에서 dashboard 여는법
 - help -> dashboard

2. sts 3.9.5 에서는 gradle이 dashboard에 없다.
 - buildship gradle integration 설치후 gradle ide pack 3.8x 설치

-- 18.07.26

1. jpa 설정
 - 메모리상에 올라가는 DB같이 사용할수 있는 데이터 입출력 모듈
 - compile('org.springframework.boot:spring-boot-starter-data-jpa')
	compile('org.springframework.boot:spring-boot-starter-jdbc')
	runtime('com.h2database:h2')
 - @Entity : 테이블로 보면 됨
 - @Id : pk
 - @GenerateValue : 자동생성값

참고 URL : 
http://millky.com/@origoni/post/1140
https://jdm.kr/blog/121

-- 18.07.27

1. 프로젝트 폴더 구조
 - WebContent, webapp 의 차이
 - WebContent의 경우 이클립스에서 만들어지는 방식
 - webapp의 경우 maven에서 만들어지는 방식
 - 개발자간의 호환성을 위해 webapp 방식 사용
 - 이클립스에선 직접 폴더 만들어야 함.
 - src : 프로그램 소스 파일을 두는 곳
 - main/java : 자바 소스 파일(.java파일)을 두는 곳
 - main/resources : 프로그램을 실행할 때 사용하는 설정 파일(.properties, .xml 등)을 두는 곳
 
 - 직접 만들어야 함. * main/webapp : HTML, CSS, JavaScript, GIF 등 정적 웹 자원을 두는 곳. (JSP파일도 여기에 둠)
 - 직접 만들어야 함. * main/webapp/WEB-INF : 웹 애플리케이션 정보 파일을 두는 곳
 
 - test : 코드를 테스트하는 소스 파일을 두는 곳
 - test/java : 단위 테스트 관련 자바 소스 파일을 두는 곳
 - bin : 소스코드가 컴파일된 *.class 파일, *properties파일, *xml파일 등

2. 이클립스 html5 기본세팅
 - preferences -> Web -> JSP Files -> Editor -> Template -> New
 - jsp for HTML5
<%@ page language="java" contentType="text/html; charset=${encoding}" pageEncoding="${encoding}"%>
<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=${encoding}">
<title>Insert title here</title>
</head>
<body>

${cursor}

</body>
</html>
 - 기본생성 되는 jsp 파일 UTF-8로 기본세팅
 - preferences -> Web -> JSP Files
 - UTF-8로 변경

3. 이클립스에서 tab대신 space사용
 - preferences -> General -> Editors -> Text Editor -> Insert spaces for tabs 체크
 - preferences -> Java -> Code Style -> formatter -> New (새로운 fomatter 생성) -> Indentation -> space Only로 변경

4. spring jsp 사용하기
 1) 관련 dependency 추가
    compile('org.springframework.boot:spring-boot-starter-web')
    compile('javax.servlet:jstl')
    providedCompile('org.apache.tomcat.embed:tomcat-embed-jasper')
 1) HelloController.java 생성 (/hello 전달받아 name에 값추가해서 view로 넘김)
  - src/main/resources/application.yml 생성
  - 새버전에서는 뷰 매핑을 spring:mvc:view: 로 사용한다. *****************
 2) hello.jsp (전달받은값을 표시)

5. spring velocity 사용하기
 1) jsp 관련 라이브러리 주석처리
 2) html 파일 생성후 vm으로 변경
--- 잘안됨.

-- 18.07.30

1. thymeleaf 설정
 - build.gradle 에 추가 org.springframework.boot:spring-boot-starter-thymeleaf
 - src/main/resources/templates/hello.html 생성

2. tomcat 설정및 java run으로 기동할수 있게 설정
 - build.gradle 에 org.springframework.boot:spring-boot-starter-tomcat 추가
 - 패키지 최상단에 @SpringBootApplication 이 있는 main 메소드 클래스가 있어야 동작
 - 딱히 SpringBootServletInitializer 를 구현한 클래스는 필요없음. (테스트 해봄)

3. bootstrap 설정
 - webjar 사용해서 설치
 - compile 'org.webjars.bower:bootstrap:4.1.3'
 - compile 'org.webjars.bower:jquery:3.3.1'
 - webjar를 사용하게 되면 lib 에 있는 jar를 참조해서 로딩한다.
<link rel="stylesheet" href="/webjars/bootstrap/4.1.3/dist/css/bootstrap.min.css">
<script src="/webjars/jquery/3.3.1/dist/jquery.min.js"></script>
<script src="/webjars/bootstrap/4.1.3/dist/js/bootstrap.min.js"></script>

4. blog sample 페이지 설정
 - compile ('org.webjars.bower:origoni-startbootstrap-clean-blog:1.0.3')
 - 추가후 blog.jsp 생성 (이미지의 경우 오래되어서 404에러 발생)

-- 18.08.24
two -> one

-- 18.11.06
1. sts 에 svn 설치
 - eclipse maketplace : SVN Team Provider 4.0.5 설치후 재시작
 - Window -> Preferences -> Team -> SVN -> SVN Connector : Get Connectors...
   SVN Kit 1.8.14 설치후 재시작

2. RestTemplate 을 이용해서 api 호출 가능
 - 파라미터의 경우 restTemplate.getForObject("http://localhost:8080/getHelloList/{num}", String.class, num); 뒤에 복수로도 붙여줄수 있다.

3. json 변환
 - json to map
   HashMap<String, Object> rs = new ObjectMapper().readValue(result.toString(), HashMap.class);
   map to json
   new ObjectMapper().writeValueAsString(rs);
 
 -- 18.11.07
 1. mybatis에서 resultType 의 vo경로를 @Alias("별명") 으로 사용할수 있다.
  - application.yml에 type-aliases-package: co.kr.lguplus 선언은 해야함.
  
 2. jackson json 사용법
  - https://www.lesstif.com/pages/viewpage.action?pageId=24445183
 
 3. @JsonProperty 사용법
  - vo에서 json과 파라미터 값이 다를경우 JsonProperty("파라미터") 를 선언해주면 그값으로 받거나 되돌려줄수 있다.
 
 -- 18.11.13
 1. json -> vo
 - ObjectMapper 로 json 문자열을 넣어 vo에 넣으면 하위 vo까지 전부 자동으로 들어감
 - 만약 빈값이 들어올 확률이 있는 항목이 있다면 @JsonInclude(Include.NON_NULL) 변수위에
   선언해 주면 됨.
   
 RestTemplate restTemplate = new RestTemplate();
 ClovaExtensionRequestDto clovaExtensionRequestDto = new ClovaExtensionRequestDto();
			ObjectMapper mapper = new ObjectMapper();
		String retVal = restTemplate.getForObject("http://localhost:8080/jsonVoTest", String.class);
		clovaExtensionRequestDto = mapper.readValue(retVal, ClovaExtensionRequestDto.class);
		System.out.println("전체 : " + clovaExtensionRequestDto.toString());
		
자동으로 json -> vo 로 들어감
		
new ObjectMapper().readValue(jsonNode.path("session").path("user").toString(), UserDto.class);

해당 json 노드만 가지고 올수도 있다.

 -- 18.11.15
 1.공통예외 처리 
  - Exception <- BaseException <- CustomException1
  - ExceptionTestController 여기서 예외 발생시킴
  - GlobalExceptionHandler : 공통예외처리
    @ControllerAdvice : 공통 예외 (전체 컨트롤러)
    @Order(Ordered.HIGHEST_PRECEDENCE) 우선순위 최상위
    @RestController : api 로 리턴 (json)
    메소드
    @ExceptionHandler(Exception.class) : Exception은 전부 여기서 처리
    new ResponseEntity<>(e, HttpStatus.BAD_REQUEST); : https status 예외처리 발생 (e에 담아 리턴하니 전체 오류메시지가 json으로 리턴됨
    
    
-- 18.11.19
aspectj 정리
포인트컷 표현식
execution(*io.icednut.spring.exercise..*Impl.get*(..))
execution(	*	io.icdenut.spring.exercise..	*Impl	.	get*(..)	)
 	리턴타입	패키지경로	클래스명	 	메소드명 매개변수	 
리턴 타입
타입	설명
*	모든 리턴타입허용
void	리턴타입 void인 메소드 선택
!void	void가 아닌 메소드 선택
패키지 경로
패키지경로	설명
io.icednut.spring.exercise	정확하게 패키지 선택
io.icednut.spring.exercise..	패키지로 시작하는 모든 패키지 선택
io.icednut.spring..impl	io.icednut.spring으로 시작하면서 마지막 패키지 이름이 Impl로 끝나는 패키지 선택
클래스명
클래스명	설명
BoardServiceImpl	정확한 클래스 선택
*Impl	이름이 Impl로 끝나는 클래스 선택
BoardService+	해당 클래스로 파생된 모든 자식 클래스 선택, 인터페이스 구현 된 모든 클래스 선택
메소드명, 매개변수
메소드명, 매개변수	설명
*	모든 메소드 선택
get*(..)	이름이 get으로 시작하는 모든 메소드 선택

-- 18.11.21
request -> filter -> interceptor -> controller

1. 필터는 요청이 처음 들어왔을경우 걸러준다.
2. 인터셉터는 컨트롤러로 가기전 걸러준다.
3. aop는 인터셉터 후 걸러줒다.
4. 응답은 필터제외하고 역순

-- 18.11.22
@JsonTypeInfo(include = As.WRAPPER_OBJECT, use = Id.NAME) 를 붙여주면 자동으로 이름이 json에 등록

객체를 json으로 리턴할경우 vo선언한대로 json으로 리턴된다.
그런데, name, value 구조로 되어있을경우 클래스명이 표현되지 않는다.
map에 name, 객체로 넣어두고 출력해보니 일단 잘 출력된다.

-- 18.11.23

vo를 잘 만들면 자동 매핑 된다.
ApiTestController
ApiTestVo
ApiTestSubListVo


-- 18.11.28

linux 오라클 접속법
su - oracle
sqlplus /nolog
connect / as sysdba

* http connection pooling
 - restTemplate 으로 접속해서 통신할때 급작스럽게 과도한 통신이 발생하면
   부하가 발생한다.
 - pool을 만들어서 안정적으로 통신할수 있다.
 - restTemplate @Configuration @Bean 으로 config 클래스를 만들어서 설정해줄수 있다.
 https://bluepoet.me/2017/09/06/resttemplate-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/
 
 
 
 
 
 
 
 
 

